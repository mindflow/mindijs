import{Logger as e,Map as n,List as t}from"./coreutil_v1.js";class s{constructor(){this.configEntries=null,this.configProcessors=null,this.instanceProcessors=null}finalize(){}isFinalized(){return!1}}class r{injectTarget(e,n,t=0){}}class i{static get NEW_INSTANCE(){return 0}static get EXISTING_INSTANCE(){return 1}static holderWithNewInstance(e){return new i(e,i.NEW_INSTANCE)}static holderWithExistingInstance(e){return new i(e,i.EXISTING_INSTANCE)}constructor(e,n){this.instance=e,this.type=n}}class o{static get NEW(){return"NEW"}static get CONFIGURED(){return"CONFIGURED"}constructor(e,n){this.name=e,this.classReference=n,this.stage=o.NEW}instanceHolder(e=[]){return null}}const c=new e("ConfigAccessor");class a{static instanceHolder(e,n,t=[]){const s=this.typeConfigByName(e,n);if(null===s)return c.error("No typeconfig found for "+e),null;const r=s.instanceHolder(t);return r||c.error("No object found for "+e),r}static typeConfigByName(e,n){let t=null;return n.configEntries.forEach(((n,s,r)=>n!==e||(t=s,!1)),this),t||c.error("No config entry found for "+e),t}}new e("ConfigProcessorExecutor");class l{static execute(e,n,t){return e.promiseChain(((e,s)=>new Promise(((s,r)=>{let o=Promise.resolve();const c=a.instanceHolder(e,t);c.type===i.NEW_INSTANCE&&(o=n.injectTarget(c.instance,t)),o.then((()=>{const e=l.prepareUnconfiguredConfigEntries(t.configEntries);c.instance.processConfig(t,e).then((()=>{s()}))}))}))))}static prepareUnconfiguredConfigEntries(e){const t=new n;return e.forEach(((e,n,s)=>{const r=n;return r.stage===o.NEW&&(t.set(e,r),r.stage=o.CONFIGURED),!0}),this),t}}new e("SingletonConfig");class h extends o{static named(e,n){return new h(e,n)}static unnamed(e){return new h(e.name,e)}constructor(e,n){super(e,n)}instanceHolder(e=[]){return this.instance?i.holderWithExistingInstance(this.instance):(e&&e.length>0?this.instance=new this.classReference(...e):this.instance=new this.classReference,i.holderWithNewInstance(this.instance))}}new e("Provider");class u{get(e=[]){return null}}class d{static get INSTANCE_TYPE(){return 0}static get PROVIDER_TYPE(){return 1}static instanceByName(e,n,t=[]){return new d(e,n,d.INSTANCE_TYPE,t)}static instance(e,n=[]){return new d(e.name,e,d.INSTANCE_TYPE,n)}static providerByName(e,n){return new d(e,n,d.PROVIDER_TYPE)}static provider(e){return new d(e.name,e,d.PROVIDER_TYPE)}constructor(e,n,t=d.INSTANCE_TYPE,s=null){this.name=e,this.classReference=n,this.type=t,this.parameters=s}}new e("InstanceProcessorExecutor");class f{static execute(e,n){return n.instanceProcessors.promiseChain(((t,s)=>a.instanceHolder(t,n).instance.process(e)),this)}}class g extends u{constructor(e,n,t){super(),this.typeConfig=e,this.injector=n,this.config=t}get(e=[]){const n=a.instanceHolder(this.typeConfig.name,this.config,e);return n.type===i.NEW_INSTANCE?this.injector.injectTarget(n.instance,this.config):Promise.resolve(n.instance)}}new e("MindiInjector");class E extends r{static inject(e,n){return P.injectTarget(e,n)}static getInstance(){return P}injectTarget(e,n,s=0){if(!e)throw Error("Missing target object");if(!n)throw Error("Missing config");if(!n.isFinalized())throw Error("Config not finalized");if(s>10)throw Error("Injection structure too deep");const r=this,i=new t(Object.keys(e));return new Promise(((t,o)=>i.promiseChain(((t,i)=>E.injectProperty(e,t,n,s,r))).then((()=>{f.execute(e,n).then((()=>{t(e)}))}))))}static injectProperty(e,n,t,s,r){const i=e[n];return i instanceof d?i.type===d.PROVIDER_TYPE?(E.injectPropertyProvider(e,n,t,r),Promise.resolve()):E.injectPropertyInstance(e,n,t,s,r):Promise.resolve()}static injectPropertyProvider(e,n,t,s){const r=e[n],i=a.typeConfigByName(r.name,t);e[n]=new g(i,s,t)}static injectPropertyInstance(e,n,t,s,r){let o=Promise.resolve();const c=e[n],l=a.instanceHolder(c.name,t,c.parameters);return l.type===i.NEW_INSTANCE&&(o=r.injectTarget(l.instance,t,s++)),e[n]=l.instance,o}}const P=new E;class m{process(e){return Promise.resolve()}}class p{processConfig(e,n){return Promise.resolve()}}new e("Config");class N extends s{constructor(){super(),this.finalized=!1,this.configEntries=new n,this.configProcessors=new t,this.instanceProcessors=new t}merge(e){this.finalized=!0;const s=new n;s.addAll(this.configEntries),s.addAll(e.configEntries);const r=new t;r.addAll(this.configProcessors),r.addAll(e.configProcessors);const i=new t;return i.addAll(this.instanceProcessors),i.addAll(e.instanceProcessors),this.configEntries=s,this.configProcessors=r,this.instanceProcessors=i,this}addTypeConfig(e){return this.finalized=!1,this.configEntries.set(e.name,e),this}addConfigProcessor(e){return this.configProcessors.add(e.name),this.addTypeConfig(h.unnamed(e))}addInstanceProcessor(e){return this.instanceProcessors.add(e.name),this.addTypeConfig(h.unnamed(e))}addAllTypeConfig(e){return this.finalized=!1,e.forEach(((e,n)=>(this.configEntries.set(e.name,e),!0)),this),this}addAllConfigProcessor(e){return e.forEach(((e,n)=>(this.configProcessors.add(e.name),this.addTypeConfig(h.unnamed(e)),!0)),this),this}addAllInstanceProcessor(e){return e.forEach(((e,n)=>(this.instanceProcessors.add(e.name),this.addTypeConfig(h.unnamed(e)),!0)),this),this}isFinalized(){return this.finalized}finalize(){return this.finalized=!0,l.execute(this.configProcessors,E.getInstance(),this)}}new e("InstancePostConfigTrigger");class w extends m{process(e){let n=null;if(e.postConfig&&(n=e.postConfig()),n||(n=new Promise(((e,n)=>{e()}))),!n instanceof Promise)throw"postConfig() must return either undefined or null or a Promise";return n}}class C extends o{static named(e,n,t){return new C(e,n,t)}static unnamed(e,n){return new C(e.name,e,n)}constructor(e,n,t){super(e,n),this.poolSize=t}instanceHolder(e=[]){}}class I extends o{static named(e,n){return new I(e,n)}static unnamed(e){return new I(e.name,e)}constructor(e,n){super(e,n)}instanceHolder(e=[]){let n=null;return n=e&&e.length>0?new this.classReference(...e):new this.classReference,i.holderWithNewInstance(n)}}export{s as Config,a as ConfigAccessor,p as ConfigProcessor,l as ConfigProcessorExecutor,d as InjectionPoint,r as Injector,i as InstanceHolder,w as InstancePostConfigTrigger,m as InstanceProcessor,f as InstanceProcessorExecutor,N as MindiConfig,E as MindiInjector,g as MindiProvider,C as PoolConfig,I as PrototypeConfig,u as Provider,h as SingletonConfig,o as TypeConfig};
