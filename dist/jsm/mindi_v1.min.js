import{Logger as e,Map as t,List as n}from"./coreutil_v1.js";class s{constructor(){this.configEntries=null,this.configProcessors=null,this.instanceProcessors=null}finalize(){}isFinalized(){return!1}}class r{static get NEW_INSTANCE(){return 0}static get EXISTING_INSTANCE(){return 1}static holderWithNewInstance(e){return new r(e,r.NEW_INSTANCE)}static holderWithExistingInstance(e){return new r(e,r.EXISTING_INSTANCE)}constructor(e,t){this.instance=e,this.type=t}}class i{static get NEW(){return"NEW"}static get CONFIGURED(){return"CONFIGURED"}constructor(e,t){this.name=e,this.classReference=t,this.stage=i.NEW}instanceHolder(e=[]){return null}}const o=new e("ConfigAccessor");class c{static instanceHolder(e,t,n=[]){const s=this.typeConfigByName(e,t);if(null===s)return o.error("No typeconfig found for "+e),null;const r=s.instanceHolder(n);return r||o.error("No object found for "+e),r}static typeConfigByName(e,t){let n=null;return t.configEntries.forEach(((t,s,r)=>t!==e||(n=s,!1)),this),n||o.error("No config entry found for "+e),n}}class a{injectTarget(e,t,n=0){}}new e("ConfigProcessorExecutor");class l{static execute(e,t,n){return e.promiseChain(((e,s)=>new Promise(((s,i)=>{let o=Promise.resolve();const a=c.instanceHolder(e,n);a.type===r.NEW_INSTANCE&&(o=t.injectTarget(a.instance,n)),o.then((()=>{const e=l.prepareUnconfiguredConfigEntries(n.configEntries);a.instance.processConfig(n,e).then((()=>{s()}))}))}))))}static prepareUnconfiguredConfigEntries(e){const n=new t;return e.forEach(((e,t,s)=>{const r=t;return r.stage===i.NEW&&(n.set(e,r),r.stage=i.CONFIGURED),!0}),this),n}}new e("SingletonConfig");class u extends i{static named(e,t){return new u(e,t)}static unnamed(e){return new u(e.name,e)}constructor(e,t){super(e,t)}instanceHolder(e=[]){return this.instance?r.holderWithExistingInstance(this.instance):(e&&e.length>0?this.instance=new this.classReference(...e):this.instance=new this.classReference,r.holderWithNewInstance(this.instance))}}new e("Provider");class h{get(e=[]){return null}}class d{static get INSTANCE_TYPE(){return 0}static get PROVIDER_TYPE(){return 1}static instanceByName(e,t,n=[]){return new d(e,t,d.INSTANCE_TYPE,n)}static instance(e,t=[]){return new d(e.name,e,d.INSTANCE_TYPE,t)}static providerByName(e,t){return new d(e,t,d.PROVIDER_TYPE)}static provider(e){return new d(e.name,e,d.PROVIDER_TYPE)}constructor(e,t,n=d.INSTANCE_TYPE,s=null){this.name=e,this.classReference=t,this.type=n,this.parameters=s}}new e("InstanceProcessorExecutor");class f{static execute(e,t){return t.instanceProcessors.promiseChain(((n,s)=>c.instanceHolder(n,t).instance.process(e)),this)}}class g extends h{constructor(e,t,n){super(),this.typeConfig=e,this.injector=t,this.config=n}get(e=[]){const t=c.instanceHolder(this.typeConfig.name,this.config,e);return t.type===r.NEW_INSTANCE?this.injector.injectTarget(t.instance,this.config):Promise.resolve(t.instance)}}new e("MindiInjector");class E extends a{static inject(e,t){return P.injectTarget(e,t)}static getInstance(){return P}async injectTarget(e,t,s=0){if(!e)throw Error("Missing target object");if(!t)throw Error("Missing config");if(!t.isFinalized())throw Error("Config not finalized");if(s>10)throw Error("Injection structure too deep");const r=this,i=new n(Object.keys(e));return await i.promiseChain(((n,i)=>E.injectProperty(e,n,t,s,r))),await f.execute(e,t),e}static injectProperty(e,t,n,s,r){const i=e[t];return i instanceof d?i.type===d.PROVIDER_TYPE?(E.injectPropertyProvider(e,t,n,r),Promise.resolve()):E.injectPropertyInstance(e,t,n,s,r):Promise.resolve()}static injectPropertyProvider(e,t,n,s){const r=e[t],i=c.typeConfigByName(r.name,n);e[t]=new g(i,s,n)}static injectPropertyInstance(e,t,n,s,i){let o=Promise.resolve();const a=e[t],l=c.instanceHolder(a.name,n,a.parameters);return l.type===r.NEW_INSTANCE&&(o=i.injectTarget(l.instance,n,s++)),e[t]=l.instance,o}}const P=new E;class p{process(e){return Promise.resolve()}}class m{processConfig(e,t){return Promise.resolve()}}new e("Config");class N extends s{constructor(){super(),this.finalized=!1,this.configEntries=new t,this.configProcessors=new n,this.instanceProcessors=new n}merge(e){this.finalized=!0;const s=new t;s.addAll(this.configEntries),s.addAll(e.configEntries);const r=new n;r.addAll(this.configProcessors),r.addAll(e.configProcessors);const i=new n;return i.addAll(this.instanceProcessors),i.addAll(e.instanceProcessors),this.configEntries=s,this.configProcessors=r,this.instanceProcessors=i,this}addTypeConfig(e){return this.finalized=!1,this.configEntries.set(e.name,e),this}addConfigProcessor(e){return this.configProcessors.add(e.name),this.addTypeConfig(u.unnamed(e))}addInstanceProcessor(e){return this.instanceProcessors.add(e.name),this.addTypeConfig(u.unnamed(e))}addAllTypeConfig(e){return this.finalized=!1,e.forEach(((e,t)=>(this.configEntries.set(e.name,e),!0)),this),this}addAllConfigProcessor(e){return e.forEach(((e,t)=>(this.configProcessors.add(e.name),this.addTypeConfig(u.unnamed(e)),!0)),this),this}addAllInstanceProcessor(e){return e.forEach(((e,t)=>(this.instanceProcessors.add(e.name),this.addTypeConfig(u.unnamed(e)),!0)),this),this}isFinalized(){return this.finalized}finalize(){return this.finalized=!0,l.execute(this.configProcessors,E.getInstance(),this)}}new e("InstancePostConfigTrigger");class w extends p{process(e){let t=null;if(e.postConfig&&(t=e.postConfig()),t||(t=new Promise(((e,t)=>{e()}))),!t instanceof Promise)throw"postConfig() must return either undefined or null or a Promise";return t}}class C extends i{static named(e,t,n){return new C(e,t,n)}static unnamed(e,t){return new C(e.name,e,t)}constructor(e,t,n){super(e,t),this.poolSize=n}instanceHolder(e=[]){}}class I extends i{static named(e,t){return new I(e,t)}static unnamed(e){return new I(e.name,e)}constructor(e,t){super(e,t)}instanceHolder(e=[]){let t=null;return t=e&&e.length>0?new this.classReference(...e):new this.classReference,r.holderWithNewInstance(t)}}export{s as Config,c as ConfigAccessor,m as ConfigProcessor,l as ConfigProcessorExecutor,d as InjectionPoint,a as Injector,r as InstanceHolder,w as InstancePostConfigTrigger,p as InstanceProcessor,f as InstanceProcessorExecutor,N as MindiConfig,E as MindiInjector,g as MindiProvider,C as PoolConfig,I as PrototypeConfig,h as Provider,u as SingletonConfig,i as TypeConfig};
