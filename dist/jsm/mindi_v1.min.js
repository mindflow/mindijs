import{Logger as e,ArrayUtils as t,MapUtils as n}from"./coreutil_v1.js";class s{constructor(){this.configEntries=null,this.configProcessors=null,this.instanceProcessors=null}finalize(){}isFinalized(){return!1}}class r{static get NEW_INSTANCE(){return 0}static get EXISTING_INSTANCE(){return 1}static holderWithNewInstance(e){return new r(e,r.NEW_INSTANCE)}static holderWithExistingInstance(e){return new r(e,r.EXISTING_INSTANCE)}constructor(e,t){this.instance=e,this.type=t}}class i{static get NEW(){return"NEW"}static get CONFIGURED(){return"CONFIGURED"}constructor(e,t){this.name=e,this.classReference=t,this.stage=i.NEW}instanceHolder(e=[]){return null}}new e("ConfigAccessor");class o{static typeConfigByName(e,t){let n=null;return t.configEntries.forEach(((t,s)=>{if(s===e)return n=t,!1})),n}}class c{injectTarget(e,t,n=0){}}const a=new e("ConfigProcessorExecutor");class f{static execute(e,n,s){return t.promiseChain(e,(e=>new Promise(((t,i)=>{let c=Promise.resolve();const g=o.typeConfigByName(e,s);if(!g)return void a.error(`No type config found for ${e}`);const h=g.instanceHolder();h.type===r.NEW_INSTANCE&&(c=n.injectTarget(h.instance,s)),c.then((()=>{const e=f.prepareUnconfiguredConfigEntries(s.configEntries);h.instance.processConfig(s,e).then((()=>{t()}))}))}))))}static prepareUnconfiguredConfigEntries(e){const t=new Map;return e.forEach(((e,n)=>{const s=e;s.stage===i.NEW&&(t.set(n,s),s.stage=i.CONFIGURED)})),t}}new e("SingletonConfig");class g extends i{static named(e,t){return new g(e,t)}static unnamed(e){return new g(e.name,e)}constructor(e,t){super(e,t)}instanceHolder(e=[]){return this.instance?r.holderWithExistingInstance(this.instance):(e&&e.length>0?this.instance=new this.classReference(...e):this.instance=new this.classReference,r.holderWithNewInstance(this.instance))}}new e("Provider");class h{get(e=[]){return null}}class u{static get INSTANCE_TYPE(){return 0}static get PROVIDER_TYPE(){return 1}static instanceByName(e,t,n=[]){return new u(e,t,u.INSTANCE_TYPE,n)}static instance(e,t=[]){return new u(e.name,e,u.INSTANCE_TYPE,t)}static providerByName(e,t){return new u(e,t,u.PROVIDER_TYPE)}static provider(e){return new u(e.name,e,u.PROVIDER_TYPE)}constructor(e,t,n=u.INSTANCE_TYPE,s=null){this.name=e,this.classReference=t,this.type=n,this.parameters=s}}new e("InstanceProcessorExecutor");class l{static execute(e,n){return t.promiseChain(n.instanceProcessors,(t=>o.typeConfigByName(t,n).instanceHolder().instance.process(e)))}}class d extends h{constructor(e,t,n){super(),this.typeConfig=e,this.injector=t,this.config=n}get(e=[]){const t=this.typeConfig.instanceHolder(e);return t.type===r.NEW_INSTANCE?this.injector.injectTarget(t.instance,this.config):Promise.resolve(t.instance)}}const p=new e("MindiInjector");class P extends c{static inject(e,t){return E.injectTarget(e,t)}static getInstance(){return E}async injectTarget(e,n,s=0){if(!e)throw Error("Missing target object");if(!n)throw Error("Missing config");if(!n.isFinalized())throw Error("Config not finalized");if(s>10)throw Error("Injection structure too deep");const r=this;return await t.promiseChain(Object.keys(e),(t=>P.injectProperty(e,t,n,s,r))),await l.execute(e,n),e}static injectProperty(e,t,n,s,r){const i=e[t];return i instanceof u?i.type===u.PROVIDER_TYPE?(P.injectPropertyProvider(e,t,n,r),Promise.resolve()):P.injectPropertyInstance(e,t,n,s,r):Promise.resolve()}static injectPropertyProvider(e,t,n,s){const r=e[t],i=P.getTypeConfig(r.name,r.classReference,n);i&&(e[t]=new d(i,s,n))}static injectPropertyInstance(e,t,n,s,i){let o=Promise.resolve();const c=e[t],a=P.getTypeConfig(c.name,c.classReference,n);if(!a)return;const f=a.instanceHolder(c.parameters);return f.type===r.NEW_INSTANCE&&(o=i.injectTarget(f.instance,n,s++)),e[t]=f.instance,o}static getTypeConfig(e,t,n){const s=o.typeConfigByName(e,n);return s||(p.error(`No type config found for ${e} and classReference does not extend AutoConfig`),null)}}const E=new P;class m{process(e){return Promise.resolve()}}class C{processConfig(e,t){return Promise.resolve()}}new e("Config");class y extends s{constructor(){super(),this.finalized=!1,this.configEntries=new Map,this.configProcessors=new Array,this.instanceProcessors=new Array}merge(e){return this.finalized=!0,this.configEntries=n.merge(this.configEntries,e.configEntries),this.configProcessors=t.merge(this.configProcessors,e.configProcessors),this.instanceProcessors=t.merge(this.instanceProcessors,e.instanceProcessors),this}addTypeConfig(e){return this.finalized=!1,this.configEntries.set(e.name,e),this}addConfigProcessor(e){return this.configProcessors=t.add(this.configProcessors,e.name),this.addTypeConfig(g.unnamed(e))}addInstanceProcessor(e){return this.instanceProcessors=t.add(this.instanceProcessors,e.name),this.addTypeConfig(g.unnamed(e))}addAllTypeConfig(e){return this.finalized=!1,e.forEach((e=>{this.configEntries.set(e.name,e)})),this}addAllConfigProcessor(e){return e.forEach((e=>{this.configProcessors=t.add(this.configProcessors,e.name),this.addTypeConfig(g.unnamed(e))})),this}addAllInstanceProcessor(e){return e.forEach((e=>{this.instanceProcessors=t.add(this.instanceProcessors,e.name),this.addTypeConfig(g.unnamed(e))})),this}isFinalized(){return this.finalized}finalize(){return this.finalized=!0,f.execute(this.configProcessors,P.getInstance(),this)}}new e("InstancePostConfigTrigger");class N extends m{process(e){let t=null;if(e.postConfig&&(t=e.postConfig()),t||(t=new Promise(((e,t)=>{e()}))),!t instanceof Promise)throw"postConfig() must return either undefined or null or a Promise";return t}}class w extends i{static named(e,t,n){return new w(e,t,n)}static unnamed(e,t){return new w(e.name,e,t)}constructor(e,t,n){super(e,t),this.poolSize=n}instanceHolder(e=[]){}}class T extends i{static named(e,t){return new T(e,t)}static unnamed(e){return new T(e.name,e)}constructor(e,t){super(e,t)}instanceHolder(e=[]){let t=null;return t=e&&e.length>0?new this.classReference(...e):new this.classReference,r.holderWithNewInstance(t)}}class I{static _instance;constructor(){this.typeConfigPackMap=new Map}static instance(){return I._instance||(I._instance=new I),I._instance}addTypeConfig(e,t){this.typeConfigPackMap.has(e)||this.typeConfigPackMap.set(e,new Map),this.typeConfigPackMap.get(e).has(t.name)||this.typeConfigPackMap.get(e).set(t.name,t)}getConfigArrayByPackName(e){return this.typeConfigPackMap.has(e)?Array.from(this.typeConfigPackMap.get(e).values()):[]}}export{s as Config,o as ConfigAccessor,C as ConfigProcessor,f as ConfigProcessorExecutor,u as InjectionPoint,c as Injector,r as InstanceHolder,N as InstancePostConfigTrigger,m as InstanceProcessor,l as InstanceProcessorExecutor,y as MindiConfig,P as MindiInjector,d as MindiProvider,w as PoolConfig,T as PrototypeConfig,h as Provider,g as SingletonConfig,i as TypeConfig,I as TypeConfigPack};
