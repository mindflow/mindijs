import{Logger as e,List as t,MapUtils as n,ArrayUtils as s}from"./coreutil_v1.js";class r{constructor(){this.configEntries=null,this.configProcessors=null,this.instanceProcessors=null}finalize(){}isFinalized(){return!1}}class i{static get NEW_INSTANCE(){return 0}static get EXISTING_INSTANCE(){return 1}static holderWithNewInstance(e){return new i(e,i.NEW_INSTANCE)}static holderWithExistingInstance(e){return new i(e,i.EXISTING_INSTANCE)}constructor(e,t){this.instance=e,this.type=t}}class o{static get NEW(){return"NEW"}static get CONFIGURED(){return"CONFIGURED"}constructor(e,t){this.name=e,this.classReference=t,this.stage=o.NEW}instanceHolder(e=[]){return null}}new e("ConfigAccessor");class c{static typeConfigByName(e,t){let n=null;return t.configEntries.forEach(((t,s)=>{if(s===e)return n=t,!1})),n}}class a{injectTarget(e,t,n=0){}}const f=new e("ConfigProcessorExecutor");class g{static execute(e,n,s){return new t(e).promiseChain(((e,t)=>new Promise(((t,r)=>{let o=Promise.resolve();const a=c.typeConfigByName(e,s);if(!a)return void f.error(`No type config found for ${e}`);const h=a.instanceHolder();h.type===i.NEW_INSTANCE&&(o=n.injectTarget(h.instance,s)),o.then((()=>{const e=g.prepareUnconfiguredConfigEntries(s.configEntries);h.instance.processConfig(s,e).then((()=>{t()}))}))}))))}static prepareUnconfiguredConfigEntries(e){const t=new Map;return e.forEach(((e,n)=>{const s=e;s.stage===o.NEW&&(t.set(n,s),s.stage=o.CONFIGURED)})),t}}new e("SingletonConfig");class h extends o{static named(e,t){return new h(e,t)}static unnamed(e){return new h(e.name,e)}constructor(e,t){super(e,t)}instanceHolder(e=[]){return this.instance?i.holderWithExistingInstance(this.instance):(e&&e.length>0?this.instance=new this.classReference(...e):this.instance=new this.classReference,i.holderWithNewInstance(this.instance))}}new e("Provider");class u{get(e=[]){return null}}class l{static get INSTANCE_TYPE(){return 0}static get PROVIDER_TYPE(){return 1}static instanceByName(e,t,n=[]){return new l(e,t,l.INSTANCE_TYPE,n)}static instance(e,t=[]){return new l(e.name,e,l.INSTANCE_TYPE,t)}static providerByName(e,t){return new l(e,t,l.PROVIDER_TYPE)}static provider(e){return new l(e.name,e,l.PROVIDER_TYPE)}constructor(e,t,n=l.INSTANCE_TYPE,s=null){this.name=e,this.classReference=t,this.type=n,this.parameters=s}}class d{process(e){return Promise.resolve()}}new e("InstanceProcessorExecutor");class p{static execute(e,n){return new t(n.instanceProcessors).promiseChain(((t,s)=>c.typeConfigByName(t,n).instanceHolder().instance.process(e)),this)}}class P extends u{constructor(e,t,n){super(),this.typeConfig=e,this.injector=t,this.config=n}get(e=[]){const t=this.typeConfig.instanceHolder(e);return t.type===i.NEW_INSTANCE?this.injector.injectTarget(t.instance,this.config):Promise.resolve(t.instance)}}const E=new e("MindiInjector");class m extends a{static inject(e,t){return C.injectTarget(e,t)}static getInstance(){return C}async injectTarget(e,n,s=0){if(!e)throw Error("Missing target object");if(!n)throw Error("Missing config");if(!n.isFinalized())throw Error("Config not finalized");if(s>10)throw Error("Injection structure too deep");const r=this,i=new t(Object.keys(e));return await i.promiseChain(((t,i)=>m.injectProperty(e,t,n,s,r))),await p.execute(e,n),e}static injectProperty(e,t,n,s,r){const i=e[t];return i instanceof l?i.type===l.PROVIDER_TYPE?(m.injectPropertyProvider(e,t,n,r),Promise.resolve()):m.injectPropertyInstance(e,t,n,s,r):Promise.resolve()}static injectPropertyProvider(e,t,n,s){const r=e[t],i=m.getTypeConfig(r.name,r.classReference,n);i&&(e[t]=new P(i,s,n))}static injectPropertyInstance(e,t,n,s,r){let o=Promise.resolve();const c=e[t],a=m.getTypeConfig(c.name,c.classReference,n);if(!a)return;const f=a.instanceHolder(c.parameters);return f.type===i.NEW_INSTANCE&&(o=r.injectTarget(f.instance,n,s++)),e[t]=f.instance,o}static getTypeConfig(e,t,n){const s=c.typeConfigByName(e,n);return s||(E.error(`No type config found for ${e} and classReference does not extend AutoConfig`),null)}}const C=new m;class y{processConfig(e,t){return Promise.resolve()}}new e("Config");class w extends r{constructor(){super(),this.finalized=!1,this.configEntries=new Map,this.configProcessors=new Array,this.instanceProcessors=new Array}merge(e){return this.finalized=!0,this.configEntries=n.merge(this.configEntries,e.configEntries),this.configProcessors=s.merge(this.configProcessors,e.configProcessors),this.instanceProcessors=s.merge(this.instanceProcessors,e.instanceProcessors),this}addTypeConfig(e){return this.finalized=!1,this.configEntries.set(e.name,e),this}addConfigProcessor(e){return this.configProcessors=s.add(this.configProcessors,e.name),this.addTypeConfig(h.unnamed(e))}addInstanceProcessor(e){return this.instanceProcessors=s.add(this.instanceProcessors,e.name),this.addTypeConfig(h.unnamed(e))}addAllTypeConfig(e){return this.finalized=!1,e.forEach((e=>{this.configEntries.set(e.name,e)})),this}addAllConfigProcessor(e){return e.forEach((e=>{this.configProcessors=s.add(this.configProcessors,e.name),this.addTypeConfig(h.unnamed(e))})),this}addAllInstanceProcessor(e){return e.forEach((e=>{this.instanceProcessors=s.add(this.instanceProcessors,e.name),this.addTypeConfig(h.unnamed(e))})),this}isFinalized(){return this.finalized}finalize(){return this.finalized=!0,g.execute(this.configProcessors,m.getInstance(),this)}}new e("InstancePostConfigTrigger");class N extends d{process(e){let t=null;if(e.postConfig&&(t=e.postConfig()),t||(t=new Promise(((e,t)=>{e()}))),!t instanceof Promise)throw"postConfig() must return either undefined or null or a Promise";return t}}class T extends o{static named(e,t,n){return new T(e,t,n)}static unnamed(e,t){return new T(e.name,e,t)}constructor(e,t,n){super(e,t),this.poolSize=n}instanceHolder(e=[]){}}class I extends o{static named(e,t){return new I(e,t)}static unnamed(e){return new I(e.name,e)}constructor(e,t){super(e,t)}instanceHolder(e=[]){let t=null;return t=e&&e.length>0?new this.classReference(...e):new this.classReference,i.holderWithNewInstance(t)}}class j{static _instance;constructor(){this.typeConfigPackMap=new Map}static instance(){return j._instance||(j._instance=new j),j._instance}addTypeConfig(e,t){this.typeConfigPackMap.has(e)||this.typeConfigPackMap.set(e,new Map),this.typeConfigPackMap.get(e).has(t.name)||this.typeConfigPackMap.get(e).set(t.name,t)}getConfigArrayByPackName(e){return this.typeConfigPackMap.has(e)?Array.from(this.typeConfigPackMap.get(e).values()):[]}}export{r as Config,c as ConfigAccessor,y as ConfigProcessor,g as ConfigProcessorExecutor,l as InjectionPoint,a as Injector,i as InstanceHolder,N as InstancePostConfigTrigger,d as InstanceProcessor,p as InstanceProcessorExecutor,w as MindiConfig,m as MindiInjector,P as MindiProvider,T as PoolConfig,I as PrototypeConfig,u as Provider,h as SingletonConfig,o as TypeConfig,j as TypeConfigPack};
