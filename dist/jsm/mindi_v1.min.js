import{Logger as e,Map as t,List as n}from"./coreutil_v1.js";class s{constructor(){this.configEntries=null,this.configProcessors=null,this.instanceProcessors=null}finalize(){}isFinalized(){return!1}}class r{static get NEW_INSTANCE(){return 0}static get EXISTING_INSTANCE(){return 1}static holderWithNewInstance(e){return new r(e,r.NEW_INSTANCE)}static holderWithExistingInstance(e){return new r(e,r.EXISTING_INSTANCE)}constructor(e,t){this.instance=e,this.type=t}}class i{static get NEW(){return"NEW"}static get CONFIGURED(){return"CONFIGURED"}constructor(e,t){this.name=e,this.classReference=t,this.stage=i.NEW}instanceHolder(e=[]){return null}}new e("ConfigAccessor");class c{static typeConfigByName(e,t){let n=null;return t.configEntries.forEach(((t,s,r)=>t!==e||(n=s,!1)),this),n}}class o{injectTarget(e,t,n=0){}}const a=new e("ConfigProcessorExecutor");class l{static execute(e,t,n){return e.promiseChain(((e,s)=>new Promise(((s,i)=>{let o=Promise.resolve();const h=c.typeConfigByName(e,n);if(!h)return void a.error(`No type config found for ${e}`);const f=h.instanceHolder();f.type===r.NEW_INSTANCE&&(o=t.injectTarget(f.instance,n)),o.then((()=>{const e=l.prepareUnconfiguredConfigEntries(n.configEntries);f.instance.processConfig(n,e).then((()=>{s()}))}))}))))}static prepareUnconfiguredConfigEntries(e){const n=new t;return e.forEach(((e,t,s)=>{const r=t;return r.stage===i.NEW&&(n.set(e,r),r.stage=i.CONFIGURED),!0}),this),n}}new e("SingletonConfig");class h extends i{static named(e,t){return new h(e,t)}static unnamed(e){return new h(e.name,e)}constructor(e,t){super(e,t)}instanceHolder(e=[]){return this.instance?r.holderWithExistingInstance(this.instance):(e&&e.length>0?this.instance=new this.classReference(...e):this.instance=new this.classReference,r.holderWithNewInstance(this.instance))}}new e("Provider");class f{get(e=[]){return null}}class u{static get INSTANCE_TYPE(){return 0}static get PROVIDER_TYPE(){return 1}static instanceByName(e,t,n=[]){return new u(e,t,u.INSTANCE_TYPE,n)}static instance(e,t=[]){return new u(e.name,e,u.INSTANCE_TYPE,t)}static providerByName(e,t){return new u(e,t,u.PROVIDER_TYPE)}static provider(e){return new u(e.name,e,u.PROVIDER_TYPE)}constructor(e,t,n=u.INSTANCE_TYPE,s=null){this.name=e,this.classReference=t,this.type=n,this.parameters=s}}new e("InstanceProcessorExecutor");class g{static execute(e,t){return t.instanceProcessors.promiseChain(((n,s)=>c.typeConfigByName(n,t).instanceHolder().instance.process(e)),this)}}class d extends f{constructor(e,t,n){super(),this.typeConfig=e,this.injector=t,this.config=n}get(e=[]){const t=this.typeConfig.instanceHolder(e);return t.type===r.NEW_INSTANCE?this.injector.injectTarget(t.instance,this.config):Promise.resolve(t.instance)}}const p=new e("MindiInjector");class P extends o{static inject(e,t){return E.injectTarget(e,t)}static getInstance(){return E}async injectTarget(e,t,s=0){if(!e)throw Error("Missing target object");if(!t)throw Error("Missing config");if(!t.isFinalized())throw Error("Config not finalized");if(s>10)throw Error("Injection structure too deep");const r=this,i=new n(Object.keys(e));return await i.promiseChain(((n,i)=>P.injectProperty(e,n,t,s,r))),await g.execute(e,t),e}static injectProperty(e,t,n,s,r){const i=e[t];return i instanceof u?i.type===u.PROVIDER_TYPE?(P.injectPropertyProvider(e,t,n,r),Promise.resolve()):P.injectPropertyInstance(e,t,n,s,r):Promise.resolve()}static injectPropertyProvider(e,t,n,s){const r=e[t],i=P.getTypeConfig(r.name,r.classReference,n);i&&(e[t]=new d(i,s,n))}static injectPropertyInstance(e,t,n,s,i){let c=Promise.resolve();const o=e[t],a=P.getTypeConfig(o.name,o.classReference,n);if(!a)return;const l=a.instanceHolder(o.parameters);return l.type===r.NEW_INSTANCE&&(c=i.injectTarget(l.instance,n,s++)),e[t]=l.instance,c}static getTypeConfig(e,t,n){const s=c.typeConfigByName(e,n);return s||(p.error(`No type config found for ${e} and classReference does not extend AutoConfig`),null)}}const E=new P;class C{process(e){return Promise.resolve()}}class m{processConfig(e,t){return Promise.resolve()}}new e("Config");class w extends s{constructor(){super(),this.finalized=!1,this.configEntries=new t,this.configProcessors=new n,this.instanceProcessors=new n}merge(e){this.finalized=!0;const s=new t;s.addAll(this.configEntries),s.addAll(e.configEntries);const r=new n;r.addAll(this.configProcessors),r.addAll(e.configProcessors);const i=new n;return i.addAll(this.instanceProcessors),i.addAll(e.instanceProcessors),this.configEntries=s,this.configProcessors=r,this.instanceProcessors=i,this}addTypeConfig(e){return this.finalized=!1,this.configEntries.set(e.name,e),this}addConfigProcessor(e){return this.configProcessors.add(e.name),this.addTypeConfig(h.unnamed(e))}addInstanceProcessor(e){return this.instanceProcessors.add(e.name),this.addTypeConfig(h.unnamed(e))}addAllTypeConfig(e){return this.finalized=!1,e.forEach(((e,t)=>(this.configEntries.set(e.name,e),!0)),this),this}addAllConfigProcessor(e){return e.forEach(((e,t)=>(this.configProcessors.add(e.name),this.addTypeConfig(h.unnamed(e)),!0)),this),this}addAllInstanceProcessor(e){return e.forEach(((e,t)=>(this.instanceProcessors.add(e.name),this.addTypeConfig(h.unnamed(e)),!0)),this),this}isFinalized(){return this.finalized}finalize(){return this.finalized=!0,l.execute(this.configProcessors,P.getInstance(),this)}}new e("InstancePostConfigTrigger");class y extends C{process(e){let t=null;if(e.postConfig&&(t=e.postConfig()),t||(t=new Promise(((e,t)=>{e()}))),!t instanceof Promise)throw"postConfig() must return either undefined or null or a Promise";return t}}class N extends i{static named(e,t,n){return new N(e,t,n)}static unnamed(e,t){return new N(e.name,e,t)}constructor(e,t,n){super(e,t),this.poolSize=n}instanceHolder(e=[]){}}class T extends i{static named(e,t){return new T(e,t)}static unnamed(e){return new T(e.name,e)}constructor(e,t){super(e,t)}instanceHolder(e=[]){let t=null;return t=e&&e.length>0?new this.classReference(...e):new this.classReference,r.holderWithNewInstance(t)}}class I{static _instance;constructor(){this.typeConfigPackMap=new Map}static instance(){return I._instance||(I._instance=new I),I._instance}addTypeConfig(e,t){this.typeConfigPackMap.has(e)||this.typeConfigPackMap.set(e,new Map),this.typeConfigPackMap.get(e).has(t.name)||this.typeConfigPackMap.get(e).set(t.name,t)}getConfigArrayByPackName(e){return this.typeConfigPackMap.has(e)?Array.from(this.typeConfigPackMap.get(e).values()):[]}}export{s as Config,c as ConfigAccessor,m as ConfigProcessor,l as ConfigProcessorExecutor,u as InjectionPoint,o as Injector,r as InstanceHolder,y as InstancePostConfigTrigger,C as InstanceProcessor,g as InstanceProcessorExecutor,w as MindiConfig,P as MindiInjector,d as MindiProvider,N as PoolConfig,T as PrototypeConfig,f as Provider,h as SingletonConfig,i as TypeConfig,I as TypeConfigPack};
