import{Logger,Map,List}from"./coreutil_v1.js";const LOG=new Logger("Provider");class Provider{get(n=[]){return null}}class InjectionPoint{static get INSTANCE_TYPE(){return 0}static get PROVIDER_TYPE(){return 1}static instanceByName(n,e,t=[]){return new InjectionPoint(n,e,InjectionPoint.INSTANCE_TYPE,t)}static instance(n,e=[]){return new InjectionPoint(n.name,n,InjectionPoint.INSTANCE_TYPE,e)}static providerByName(n,e){return new InjectionPoint(n,e,InjectionPoint.PROVIDER_TYPE)}static provider(n){return new InjectionPoint(n.name,n,InjectionPoint.PROVIDER_TYPE)}constructor(n,e,t=InjectionPoint.INSTANCE_TYPE,o=null){this.name=n,this.classReference=e,this.type=t,this.parameters=o}}class Config{constructor(){this.configEntries=null,this.configProcessors=null,this.instanceProcessors=null}finalize(){}isFinalized(){return!1}}class InstanceHolder{static get NEW_INSTANCE(){return 0}static get EXISTING_INSTANCE(){return 1}static holderWithNewInstance(n){return new InstanceHolder(n,InstanceHolder.NEW_INSTANCE)}static holderWithExistingInstance(n){return new InstanceHolder(n,InstanceHolder.EXISTING_INSTANCE)}constructor(n,e){this.instance=n,this.type=e}}class TypeConfig{static get NEW(){return"NEW"}static get CONFIGURED(){return"CONFIGURED"}constructor(n,e){this.name=n,this.classReference=e,this.stage=TypeConfig.NEW}instanceHolder(n=[]){return null}}const LOG$1=new Logger("ConfigAccessor");class ConfigAccessor{static instanceHolder(n,e,t=[]){const o=this.typeConfigByName(n,e);if(null===o)return LOG$1.error("No typeconfig found for "+n),null;const i=o.instanceHolder(t);return i||LOG$1.error("No object found for "+n),i}static typeConfigByName(n,e){let t=null;return e.configEntries.forEach((e,o,i)=>{if(e===n)return t=o,!1;return!0},this),t||LOG$1.error("No config entry found for "+n),t}}class ConfigProcessor{processConfig(n,e){return Promise.resolve()}}class Injector{injectTarget(n,e,t=0){}}const LOG$2=new Logger("ConfigProcessorExecutor");class ConfigProcessorExecutor{static execute(n,e,t){return n.promiseChain((n,o)=>new Promise((o,i)=>{let r=Promise.resolve();const s=ConfigAccessor.instanceHolder(n,t);s.type===InstanceHolder.NEW_INSTANCE&&(r=e.injectTarget(s.instance,t));r.then(()=>{const n=ConfigProcessorExecutor.prepareUnconfiguredConfigEntries(t.configEntries);s.instance.processConfig(t,n).then(()=>{o()})})}))}static prepareUnconfiguredConfigEntries(n){const e=new Map;return n.forEach((n,t,o)=>{const i=t;i.stage===TypeConfig.NEW&&(e.set(n,i),i.stage=TypeConfig.CONFIGURED);return!0},this),e}}class InstanceProcessor{process(n){return Promise.resolve()}}const LOG$3=new Logger("InstancePostConfigTrigger");class InstancePostConfigTrigger extends InstanceProcessor{process(n){let e=null;if(n.postConfig&&(e=n.postConfig()),e||(e=new Promise((n,e)=>{n()})),!e instanceof Promise)throw"postConfig() must return either undefined or null or a Promise";return e}}const LOG$4=new Logger("InstanceProcessorExecutor");class InstanceProcessorExecutor{static execute(n,e){return e.instanceProcessors.promiseChain((t,o)=>{const i=ConfigAccessor.instanceHolder(t,e);return i.instance.process(n)},this)}}const LOG$5=new Logger("SingletonConfig");class SingletonConfig extends TypeConfig{static named(n,e){return new SingletonConfig(n,e)}static unnamed(n){return new SingletonConfig(n.name,n)}constructor(n,e){super(n,e)}instanceHolder(n=[]){return this.instance?InstanceHolder.holderWithExistingInstance(this.instance):(n&&n.length>0?this.instance=new this.classReference(...n):this.instance=new this.classReference,InstanceHolder.holderWithNewInstance(this.instance))}}class MindiProvider extends Provider{constructor(n,e,t){super(),this.typeConfig=n,this.injector=e,this.config=t}get(n=[]){const e=ConfigAccessor.instanceHolder(this.typeConfig.name,this.config,n);return e.type===InstanceHolder.NEW_INSTANCE?this.injector.injectTarget(e.instance,this.config):Promise.resolve(e.instance)}}const LOG$6=new Logger("MindiInjector");class MindiInjector extends Injector{static inject(n,e){return INJECTOR.injectTarget(n,e)}static getInstance(){return INJECTOR}injectTarget(n,e,t=0){if(!n)throw Error("Missing target object");if(!e)throw Error("Missing config");if(!e.isFinalized())throw Error("Config not finalized");if(t>10)throw Error("Injection structure too deep");const o=this,i=new List(Object.keys(n));return new Promise((r,s)=>i.promiseChain((i,r)=>MindiInjector.injectProperty(n,i,e,t,o)).then(()=>{InstanceProcessorExecutor.execute(n,e).then(()=>{r(n)})}))}static injectProperty(n,e,t,o,i){const r=n[e];return r instanceof InjectionPoint?r.type===InjectionPoint.PROVIDER_TYPE?(MindiInjector.injectPropertyProvider(n,e,t,i),Promise.resolve()):MindiInjector.injectPropertyInstance(n,e,t,o,i):Promise.resolve()}static injectPropertyProvider(n,e,t,o){const i=n[e],r=ConfigAccessor.typeConfigByName(i.name,t);n[e]=new MindiProvider(r,o,t)}static injectPropertyInstance(n,e,t,o,i){let r=Promise.resolve();const s=n[e],c=ConfigAccessor.instanceHolder(s.name,t,s.parameters);return c.type===InstanceHolder.NEW_INSTANCE&&(r=i.injectTarget(c.instance,t,o++)),n[e]=c.instance,r}}const INJECTOR=new MindiInjector,LOG$7=new Logger("Config");class MindiConfig extends Config{constructor(){super(),this.finalized=!1,this.configEntries=new Map,this.configProcessors=new List,this.instanceProcessors=new List}merge(n){this.finalized=!0;const e=new Map;e.addAll(this.configEntries),e.addAll(n.configEntries);const t=new List;t.addAll(this.configProcessors),t.addAll(n.configProcessors);const o=new List;return o.addAll(this.instanceProcessors),o.addAll(n.instanceProcessors),this.configEntries=e,this.configProcessors=t,this.instanceProcessors=o,this}addTypeConfig(n){return this.finalized=!1,this.configEntries.set(n.name,n),this}addConfigProcessor(n){return this.configProcessors.add(n.name),this.addTypeConfig(SingletonConfig.unnamed(n))}addInstanceProcessor(n){return this.instanceProcessors.add(n.name),this.addTypeConfig(SingletonConfig.unnamed(n))}addAllTypeConfig(n){return this.finalized=!1,n.forEach((n,e)=>{this.configEntries.set(n.name,n);return!0},this),this}addAllConfigProcessor(n){return n.forEach((n,e)=>{this.configProcessors.add(n.name);this.addTypeConfig(SingletonConfig.unnamed(n));return!0},this),this}addAllInstanceProcessor(n){return n.forEach((n,e)=>{this.instanceProcessors.add(n.name);this.addTypeConfig(SingletonConfig.unnamed(n));return!0},this),this}isFinalized(){return this.finalized}finalize(){return this.finalized=!0,ConfigProcessorExecutor.execute(this.configProcessors,MindiInjector.getInstance(),this)}}class PoolConfig extends TypeConfig{static named(n,e,t){return new PoolConfig(n,e,t)}static unnamed(n,e){return new PoolConfig(n.name,n,e)}constructor(n,e,t){super(n,e),this.poolSize=t}instanceHolder(n=[]){}}class PrototypeConfig extends TypeConfig{static named(n,e){return new PrototypeConfig(n,e)}static unnamed(n){return new PrototypeConfig(n.name,n)}constructor(n,e){super(n,e)}instanceHolder(n=[]){let e=null;return e=n&&n.length>0?new this.classReference(...n):new this.classReference,InstanceHolder.holderWithNewInstance(e)}}export{Config,ConfigAccessor,ConfigProcessor,ConfigProcessorExecutor,InjectionPoint,Injector,InstanceHolder,InstancePostConfigTrigger,InstanceProcessor,InstanceProcessorExecutor,MindiConfig,MindiInjector,MindiProvider,PoolConfig,PrototypeConfig,Provider,SingletonConfig,TypeConfig};
